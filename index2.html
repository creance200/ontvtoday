<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Programme TV — Timeline</title>
  <link href="https://unpkg.com/vis-timeline@latest/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  
  <style>
    body {background-color: white; color: black;  font-family: Arial, sans-serif; font-size: 20px; margin: 10px; }
	body.dark-mode { background-color: black; color: white; }
    #timeline { width: 100%; height: 620px; border: 1px solid #ccc; }
	
    .controls { margin-bottom: 15px; }
	
	.HideIfLandscape { display:block;}
	@media (max-width: 1024px) and (orientation: landscape) {
      .HideIfLandscape { display: none !important; }
    }

    #custom-tooltip {
      position: absolute;
      display: none;
      background-color: white;
      border: 1px solid #ccc;
      padding: 10px;
      max-width: 500px;
      z-index: 1000;
      box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
      pointer-events: none;
    }
	
	.scrollable-div {
	  width: 400px; /* Largeur fixe */
	  height: 500px; /* Hauteur fixe */
	  overflow: auto; /* La barre de défilement apparaît seulement si nécessaire */
	  /* ou overflow: scroll; pour une barre de défilement toujours visible */
	}
  </style>
</head>
<body>
	<h5>Programme TV — Timeline</h5>
	<div class="container-fluid">
		<div class="row">
			<div class="col-lg-10 col-sm-9"></div>
			<div class="col HideIfLandscape">
				<button onclick="toggleDarkMode()">Changer de style</button>
			</div>
		</div>
	</div>
	<div class="controls">
		<div class="container-fluid">
			<div class="row">
				<div class="col-lg-1 col-2">
					<a href="https://xmltvfr.fr/xmltv/xmltv_fr.zip" style="margin-right:10px"><i class="fa-solid fa-cloud-arrow-down"></i>xmltv.zip</a>
				</div>
				<div class="col-lg-2 col-3">
					<input type="file" id="xmltvFile" accept=".xml" />
				</div>
				<div class="col-lg-3 col-7 HideIfLandscape">
					<select id="channelSelect" multiple size="7" style="width:270px;"></select>
				</div>
				<div class="col-lg-2 col-4 HideIfLandscape" style="align-content : end;">
					<label>Début :</label> <input type="time" id="startTime" value="21:00" />
				</div>
				<div class="col-lg-2 col-4 HideIfLandscape" style="align-content : end;">
					<label>Fin :</label> <input type="time" id="endTime" value="22:00" />
				</div>
				<div class="col-lg-2 col-3" style="align-content : end; padding-left:10px;">
					<button id="filterButton">Afficher la timeline</button>
				</div>
			</div>
		</div>
	</div>
	

  <div id="timeline"></div>
  <div id="custom-tooltip"></div>

  <script src="https://unpkg.com/vis-timeline@latest/standalone/umd/vis-timeline-graph2d.min.js"></script>
  <script>
    let xmlDoc, channelsMap = {};
	let timeline = null;
    
	function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
    }
	
    const preselectedChannelNames = [
      "Canal+ Cinema","Ciné+ Emotion","Ciné+ Frisson", "Ciné+ Family",
	  "OCS","Club RTL", "La Une","La Trois","M6","Plug RTL","RTL TVI",
      "TF1","TF1 Séries‑Films","France 2","W9", "CANAL+ BOX OFFICE","6ter",
	  "AB3", "Action", "Cstar", "RTL9", "Science et Vie TV",
	  "TF1 Séries-Films", "13ème rue", "Tipik", "OCS Max", "TMC"
    ];

	<!-- Chargement fichier xml par défaut -->
<!--https://github.com/creance200/ontvtoday/blob/dd7549d474afb8494d470dadc8d922286a58825d/tmp/xmltv_fr.xml -->
<!--https://github.com/creance200/ontvtoday/raw/refs/heads/main/tmp/xmltv_fr.xml -->
	fetch("https://raw.githubusercontent.com/creance200/ontvtoday/main/tmp/xmltv_fr.xml")
	  .then(response => response.text())
	  .then(str => {
		const parser = new DOMParser();
		xmlDoc = parser.parseFromString(str, "text/xml");
		populateChannels(xmlDoc);
		generate_timeline();
	  })
	  .catch(err => console.error(err));

	document.getElementById('xmltvFile').addEventListener('change', e => {
	  const file = e.target.files[0];
	  if (!file) return;

	  readXmlFile_and_populateChannels(file);

	});
	
	function readXmlFile_and_populateChannels(file) {
	  const reader = new FileReader();

	  reader.onload = function (event) {
		const parser = new DOMParser();
		xmlDoc = parser.parseFromString(event.target.result, "text/xml");
		populateChannels();
	  };

	  reader.readAsText(file);
	}
	
	function tronquer(chaine, tailleMax) {
	  if (chaine.length > tailleMax) {
		// -3 pour faire de la place pour les "..."
		return chaine.slice(0, tailleMax - 3) + "...";
	  } else {
		return chaine;
	  }
	}	

    function populateChannels() {
      const select = document.getElementById('channelSelect');
      select.innerHTML = '';
      channelsMap = {};
      xmlDoc.querySelectorAll('channel').forEach(channel => {
        const id = channel.getAttribute('id');
        const name = channel.querySelector('display-name')?.textContent || id;
        const img = channel.querySelector('icon')?.getAttribute('src')
        //channelsMap[id] = name;
		channelsMap[id] = '<span><img src="'+img+'" width="60" height="50" alt="'+name+'" title="'+name+'"></span>';
        const option = new Option(name, id);
        if (preselectedChannelNames.includes(name)) option.selected = true;
        select.add(option);
      });
    }
	
    document.getElementById('filterButton').addEventListener('click', () => {
      if (!xmlDoc) return alert('Chargez d’abord un fichier XMLTV.');

	  generate_timeline();
	}
															 
	function generate_timeline() {
      const selected = Array.from(document.querySelector('#channelSelect').selectedOptions).map(o => o.value);
      if (!selected.length) return alert('Sélectionne au moins une chaîne.');

      const start = document.getElementById('startTime').value;
      const end = document.getElementById('endTime').value;
      const today = new Date().toISOString().split('T')[0];

      const items = [], groupsMap = {};
      let groupId = 0;

      xmlDoc.querySelectorAll('programme').forEach((prog, idx) => {
        const ch = prog.getAttribute('channel');
        if (!selected.includes(ch)) return;

        const startAttr = prog.getAttribute('start').slice(0,14);
        const endAttr = prog.getAttribute('stop').slice(0,14);
        const dtStart = new Date(`${startAttr.slice(0,4)}-${startAttr.slice(4,6)}-${startAttr.slice(6,8)}T${startAttr.slice(8,10)}:${startAttr.slice(10,12)}`);
        const dtEnd = new Date(`${endAttr.slice(0,4)}-${endAttr.slice(4,6)}-${endAttr.slice(6,8)}T${endAttr.slice(8,10)}:${endAttr.slice(10,12)}`);

        const filterStart = new Date(`${today}T${start}`), filterEnd = new Date(`${today}T${end}`);
        if (dtEnd <= filterStart || dtStart >= filterEnd) return;

        if (!(ch in groupsMap)) {
          groupsMap[ch] = ++groupId;
        }

		const title = prog.querySelector('title')?.textContent || 'Sans titre';
		const desc = prog.querySelector('desc')?.textContent || 'Sans titre';
		const icon = prog.querySelector('icon')?.getAttribute('src');
		/*const deschtml = '<div style="width:40%; border: solid red;">'+desc+'<img src="'+icon+'"></div>';*/
		const deschtml = '<div class="scrollable-div"><p>'+tronquer(desc, 180)+'<p><img src="'+icon+'" width="350" height="auto"></div>';

		let content = title;
		dtEnd.setSeconds(dtEnd.getSeconds() - 1);	// Enlève 1 seconde à l'heure de fin pour éviter chevauchement

		items.push({
		  id: idx + 1,
		  content:  '<a href="https://www.google.com/search?q=allociné '+content+'">'+content+'</a>',
		  title: deschtml,
		  start: dtStart,
		  end: dtEnd,
		  group: groupsMap[ch]
		});
		
      });

      const groups = Object.entries(groupsMap).map(([ch, id]) => ({ id, content: channelsMap[ch] }));

      const container = document.getElementById('timeline');
      const data = new vis.DataSet(items);
      const options = { stack: false, 
						editable: false, 
						margin: { item: 10, axis: 5 }, 
						orientation: 'top', 
						verticalScroll: true, // Active le scroll vertical (ajout visuel seulement)
						maxHeight: '620px',
						zoomable: false,
						showTooltips: false, // Désactive les infobulles par défaut
						template: function (item) {
									if (!item) return '';
									const div = document.createElement("div");
									div.innerHTML = item.content; // permet d'interpréter le HTML
									return div;
								  }

						};

	  if(timeline != undefined && timeline != null)
		timeline.destroy();
		
	  timeline = new vis.Timeline(container, data, groups, options);
	  
    // Ajout du zoom avec Ctrl + roulette
    container.addEventListener('wheel', function (event) {
      if (event.ctrlKey) {
        event.preventDefault(); // Empêche le zoom de la page
        if (event.deltaY < 0) {
          timeline.zoomIn(0.5); // Zoom avant
        } else {
          timeline.zoomOut(0.5); // Zoom arrière
        }
      }
    }, { passive: false });
	
	// START tool-tip code ==================================================
	// Afficher l'infobulle personnalisée au survol
	const tooltip = document.getElementById('custom-tooltip');
	timeline.on('itemover', function (props) {
	const item = data.get(props.item);
	tooltip.innerHTML = item.title;
	tooltip.style.display = 'block';
	});

	// Déplacer l'infobulle avec la souris
	container.addEventListener('mousemove', function (e) {
	tooltip.style.left = (e.pageX + 15) + 'px';
	tooltip.style.top = (e.pageY + 15) + 'px';
	});

	// Cacher l'infobulle quand on sort de l'item
	timeline.on('itemout', function (props) {
	tooltip.style.display = 'none';
	});
	
	// END tool-tip code ====================================================
	
    });
	
  </script>
</body>

</html>



